<link rel="import" href="view-element.html">
<link rel="import" href="travlendar-styles.html">
<dom-module id="add-calendar-view-element">
    <template>
        <style include="travlendar-styles"></style>
        <firebase-document id="document" app-name="travlendar" path="/events/[[user.uid]]/" data="{{newEvent}}">
        </firebase-document>
        <firebase-query id="query" app-name="travlendar" path="/events/[[user.uid]]" data="{{events}}">
        </firebase-query>
        <firebase-query id="queryBreak" app-name="travlendar" path="/preferences/[[user.uid]]" data="{{pref}}">
        </firebase-query>
        <template-view>
            <span slot="outputPanel">
                <iron-input bind-value="{{newEvent.title}}">
                Title:
                <input value="{{value::input}}">
                </iron-input>
                <iron-input bind-value="{{newEvent.location}}">
                    Location:
                    <input value2="{{value2::input}}">
                </iron-input>
                <iron-input bind-value="{{newEvent.date}}">
                    Date:
                    <input value3="{{value3::input}}">
                </iron-input>
                <iron-input bind-value="{{newEvent.from}}">
                    From:
                    <input value4="{{value4::input}}">
                </iron-input>
                <iron-input bind-value="{{newEvent.to}}">
                    To:<input value5="{{value5::input}}">
                </iron-input>
            </span>
            <span slot="textPanel">
                Choose data and press save
            </span>
            <span slot="inputPanel">
                <paper-icon-item class="menu-item" on-tap="filterAndSortEvents">
                    <iron-icon icon="add" slot="item-icon"></iron-icon>Save New Event
                </paper-icon-item>
                <paper-icon-item class="menu-item" onclick="window.location.href = '#editCalendarView'">
                    <iron-icon icon="myicons:arrow-back" slot="item-icon"></iron-icon>Cancel
                </paper-icon-item>
            </span>
        </template-view>
    </template>
    <script>
    var currentEvents = [];
    numberOfApiCalls = 0;
    targetNumberOfApiCalls = 0;
    class AddCalendarViewElement extends ViewElement {
        static get is() { return 'add-calendar-view-element'; }
        static get properties() {}
        constructor() {
            super();
        }
        ready() {
            super.ready();
            window.addEventListener('feasibility-time-checked', (e) => this.checkEvent(e.detail.feasible, e.detail.firstCall));
        }

        filterAndSortEvents() {
            //if (this.$.eventForm.validate() && this.newEvent.location != null) {
            currentEvents = [];
            var newEvent = this.$.document.data;
            var events = this.$.query.data;
            var currentDay = new Date(parseInt(newEvent.date));
            var today = new Date();
            if (currentDay.getDate() < today.getDate() && newEvent.from > newEvent.to) {
                alert("data not inserted correct, please check data or time inserted");
            } else {
                for (var i = 0; i < events.length; i++) { //filter for the current day of the event added
                    var d = new Date(parseInt(events[i].date));
                    if (d.getDate() == currentDay.getDate()) {
                        currentEvents.push(events[i]);
                    }
                }
                currentEvents.push(newEvent);
                currentEvents.sort(function(a, b) { return a.from - b.from }); //sort it.
                this.checkEvent(true, true);
            }
            //}
        }

        checkEvent(feasible, firstCall) {
            var position = currentEvents.indexOf(this.$.document.data);
            var prev = currentEvents[position - 1]
            var curr = currentEvents[position];
            var next = currentEvents[position + 1];
            if (firstCall) {
                targetNumberOfApiCalls = 0; //reset values;
                numberOfApiCalls = 0;
                if (currentEvents.length > 1) {
                    if (position == 0) { //inserted event has no predecessor
                        if (parseInt(curr.to) < parseInt(next.from)) {
                            targetNumberOfApiCalls = 1;
                            this.checkTimeFeasibility(curr, next); //each call it will increment by one the numebersOfApiCall
                        } else {
                            feasible = false;
                            alert("events overlapping");
                        }
                    } else {
                        if (position == currentEvents.length - 1) { //inserted event has no successor
                            if (parseInt(prev.to) < parseInt(curr.from)) {
                                targetNumberOfApiCalls = 1;
                                this.checkTimeFeasibility(prev, curr);
                            } else {
                                feasible = false;
                                alert("events overlapping");
                            }
                        } else { //inserted event is in the middle of two event
                            if ((parseInt(prev.to) < parseInt(curr.from)) && (parseInt(curr.to) < parseInt(next.from))) {
                                targetNumberOfApiCalls = 2;
                                this.checkTimeFeasibility(prev, curr);
                            } else {
                                feasible = false;
                                alert("events overlapping");
                            }
                        }
                    }
                } else { //if is the first event of the day only check for break preferences and then eventually add it 
                    this.checkBreakPreferences();
                }
            } else {
                console.log("numberOfApiCalls = " + numberOfApiCalls + "targetNumberOfApiCalls = " + targetNumberOfApiCalls);
                if (numberOfApiCalls < targetNumberOfApiCalls) { //i've inserted an event between other two events and so i have to do another apiCall to check the feasibility 
                    this.checkTimeFeasibility(curr, next);
                } else { //i'm ready to check the feasibility 
                    if (feasible) {
                        this.checkBreakPreferences();
                    }
                }
            }
        }

        checkBreakPreferences() {
            var data = this.$.queryBreak.data;
            var lowerBound = parseInt(this.$.queryBreak.data[0].lowerBound);
            var upperBound = parseInt(this.$.queryBreak.data[0].upperBound);
            var minTime = parseInt(this.$.queryBreak.data[0].minTime);

            var position = currentEvents.indexOf(this.$.document.data);
            var prev = currentEvents[position - 1]
            var curr = currentEvents[position];
            var next = currentEvents[position + 1];
            if (position != 0) {
                var prevTo = parseInt(prev.to);
                var prevFrom = parseInt(prev.from);
            }
            var currTo = parseInt(curr.to);
            var currFrom = parseInt(curr.from);
            if (position != currentEvents.length - 1) {
                var nextTo = parseInt(next.to);
                var nextFrom = parseInt(next.from);
            }

            if (currTo < lowerBound || currFrom > upperBound) {
                //new event is not in break interval;
                this.saveEvent();
            } else {
                if ((position != 0 && (currFrom - prevTo) > minTime && (currFrom - lowerBound) > minTime) || (position == 0 && (currFrom - lowerBound) > minTime)) {
                    //check prev or lower bound feasibility
                    this.saveEvent();
                } else {
                    //check next or upper bound feasibility 
                    if ((position != currentEvents.length - 1 && (nextFrom - currTo) > minTime && (upperBound - currTo ) > minTime) || position == currentEvents.length - 1 && (upperBound - currTo) > minTime) {
                        this.saveEvent();
                    } else {
                        alert("event not feasible with the break time preferences");
                    }
                }
            }
        }

        checkTimeFeasibility(start, end) {
            var directionsService = new google.maps.DirectionsService();
            var request = {
                origin: start.location,
                destination: end.location,
                travelMode: 'TRANSIT',
                transitOptions: { //TODO check for GMT date because probably add +1 automatically
                    departureTime: new Date(parseInt(start.date) + parseInt(start.to) * 60 * 1000)
                }
            };
            directionsService.route(request, function(response, status) {
                numberOfApiCalls++;
                console.log("After increment numberOfApiCalls = " + numberOfApiCalls + "targetNumberOfApiCalls = " + targetNumberOfApiCalls);
                if (status == 'OK') { // we have always one route and one leg in this case
                    var duration = response.routes[0].legs[0].duration.value / 60;
                    if (parseInt(start.to) + duration < parseInt(end.from)) {
                        window.dispatchEvent(new CustomEvent('feasibility-time-checked', { detail: { feasible: true, firstCall: false } }));
                    } else {
                        alert("event NOT feasible");
                    }
                } else {

                    alert(status);
                }
            });
        }

        saveEvent() {
            this.$.document.saveValue('/events/' + this.user.uid);
            //TODO empty input text
            this.$.document.reset().then(function() {
                window.location.href = '#editCalendarView';
            });
        }
    }
    customElements.define(AddCalendarViewElement.is, AddCalendarViewElement);
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAoZU1vQtj2p_QUMsE1J5kWURi0G7U8Txw" async defer></script>
</dom-module>